```{asis, echo = {{proj_area_knit & !proj_area_extent_knit & proj_area_threshold_knit}}, eval = {{proj_area_knit  & !proj_area_extent_knit & !proj_area_threshold_knit}}, include = {{proj_area_knit & !proj_area_extent_knit & !proj_area_threshold_knit}}}
## Project model
Projecting the model to a new user drawn area 
```

```{r, echo =  {{proj_area_knit & !proj_area_extent_knit & !proj_area_threshold_knit}}, include = {{proj_area_knit & !proj_area_extent_knit & !proj_area_threshold_knit}}}
# First must generate the projection area according to the drawn polygon in the GUI
proj_draw_{{spAbr}} <-proj_draw(
  polyPjXY = matrix({{polyPjXY_rmd}},ncol=2,byrow=FALSE),
  polyPjID = {{polyPjID_rmd}},
  drawPjBuf = {{BgBuf_rmd}})
# Create object of projection variables
projAreaEnvs_{{spAbr}} <- envs_{{spAbr}}
# Generate a projection of the model to the desired area
proj_area_{{spAbr}} <- proj_area(
  evalOut = model_{{spAbr}},
  curModel = "{{curModel_rmd}}",
  envs = projAreaEnvs_{{spAbr}} , 
  outputType = "{{outputType_rmd}}",
  alg = "{{alg_rmd}}",
  clamp = {{clamp_rmd}},
  pjExt = proj_draw_{{spAbr}}) 
# store the cropped projection variables
projExt_{{spAbr}} <- proj_area_{{spAbr}}$projExt
 #map result
 
 ###Make map of projection
bb_{{spAbr}} <-  bgExt_{{spAbr}}@bbox
bbZoom <- alfred.polyZoom(bb_{{spAbr}}[1, 1], bb_{{spAbr}}[2, 1], bb_{{spAbr}}[1, 2], 
                   bb_{{spAbr}}[2, 2], fraction = 0.05)
mapProjVals_{{spAbr}} <- alfred.getRasterVals(proj_area_{{spAbr}}$projArea,"{{outputType_rmd}}")
rasCols_{{spAbr}} <- c("#2c7bb6", "#abd9e9", "#ffffbf", "#fdae61", "#d7191c")
# if no threshold specified
legendPal <- colorNumeric(rev(rasCols_{{spAbr}}), mapProjVals_{{spAbr}}, na.color = 'transparent')
rasPal_{{spAbr}} <- colorNumeric(rasCols_{{spAbr}}, mapProjVals_{{spAbr}}, na.color = 'transparent')
m <- leaflet() %>% addProviderTiles(providers$Esri.WorldTopoMap) 
m %>%
  fitBounds(bbZoom[1], bbZoom[2], bbZoom[3], bbZoom[4]) %>%
  leaflet::addLegend("bottomright", pal = legendPal,
            title = "Predicted Suitability<br>(Projected)",
            values = mapProjVals_{{spAbr}}, layerId = 'proj',
            labFormat = alfred.reverseLabel(2, reverse_order = TRUE)) %>%
# map model prediction raster and projection polygon
  clearMarkers() %>% clearShapes() %>% removeImage('projRas') %>%
  addRasterImage(proj_area_{{spAbr}}$projArea, colors = rasPal_{{spAbr}}, opacity = 0.7,
                 layerId = 'projRas', group = 'proj', method = "ngb") %>%
 ##add projection polygon (user drawn area)
  addPolygons(data = proj_draw_{{spAbr}}, fill = FALSE,
              weight = 4, color = "blue", group = 'proj')

```

```{asis, echo = {{proj_area_knit & !proj_area_extent_knit & proj_area_threshold_knit}}, eval = {{proj_area_knit  & !proj_area_extent_knit & proj_area_threshold_knit}}, include = {{proj_area_knit & !proj_area_extent_knit & proj_area_threshold_knit}}}
## Project model
Projecting the model to a new user drawn area using a "{{proj_thresholdRule_rmd}}" threshold of {{proj_threshold_rmd}}. 
```

```{r, echo =  {{proj_area_knit & !proj_area_extent_knit & proj_area_threshold_knit}}, include = {{proj_area_knit & !proj_area_extent_knit & proj_area_threshold_knit}}}
# First must generate the projection area according to the drawn polygon in the GUI
proj_draw_{{spAbr}} <-proj_draw(
  polyPjXY = matrix({{polyPjXY_rmd}},ncol=2,byrow=FALSE),
  polyPjID = {{polyPjID_rmd}},
  drawPjBuf = {{BgBuf_rmd}})
# Create object of projection variables
projAreaEnvs_{{spAbr}} <- envs_{{spAbr}}
# Generate a projection of the model to the desired area
proj_area_{{spAbr}} <- proj_area(
  evalOut = model_{{spAbr}},
  curModel = "{{curModel_rmd}}",
  envs = projAreaEnvs_{{spAbr}} , 
  outputType = "{{outputType_rmd}}",
  alg = "{{alg_rmd}}",
  clamp = {{clamp_rmd}},
  pjExt = proj_draw_{{spAbr}}) 

#store the cropped projection variables
projExt_{{spAbr}} <- proj_area_{{spAbr}}$projExt

# extract the suitability values for all occurrences
occs_xy_{{spAbr}} <- occs_{{spAbr}}[c('longitude', 'latitude')]
# determine the threshold based on the current prediction
occPredVals_{{spAbr}} <- raster::extract(predSel_{{spAbr}}, occs_xy_{{spAbr}})
# Define probability of quantile based on selected threshold
proj_thresProb_{{spAbr}} <- switch("{{proj_thresholdRule_rmd}}", 
                                   "mtp" = 0, "p10" = 0.1, "qtp" = {{proj_probQuantile_rmd}})
# Define threshold value
proj_thres_{{spAbr}} <- stats::quantile(occPredVals_{{spAbr}}, 
                                 probs = proj_thresProb_{{spAbr}})
# Add threshold if specified 
proj_area_{{spAbr}} <- proj_area_{{spAbr}}$projArea > proj_thres_{{spAbr}}

##Make map
###Make map of projection
bb_{{spAbr}} <-  bgExt_{{spAbr}}@bbox
bbZoom <- alfred.polyZoom(bb_{{spAbr}}[1, 1], bb_{{spAbr}}[2, 1], bb_{{spAbr}}[1, 2], 
                   bb_{{spAbr}}[2, 2], fraction = 0.05)
mapProjVals_{{spAbr}} <- alfred.getRasterVals(proj_area_{{spAbr}},"{{outputType_rmd}}")

# if threshold specified
rasPal_{{spAbr}} <- c('gray', 'red')
m <- leaflet() %>% addProviderTiles(providers$Esri.WorldTopoMap) 
m %>%
  fitBounds(bbZoom[1], bbZoom[2], bbZoom[3], bbZoom[4]) %>%
  leaflet::addLegend("bottomright", colors = c('gray', 'red'),
            title = "Thresholded Suitability<br>(Projected)",
            labels = c("predicted absence", "predicted presence"),
            opacity = 1, layerId = 'proj')%>%

# map model prediction raster and projection polygon
  clearMarkers() %>% clearShapes() %>% removeImage('projRas') %>%
  addRasterImage(proj_area_{{spAbr}}, colors = rasPal_{{spAbr}}, opacity = 0.7,
                 layerId = 'projRas', group = 'proj', method = "ngb") %>%
 ##add projection polygon (user drawn area)
  addPolygons(data = proj_draw_{{spAbr}}, fill = FALSE,
              weight = 4, color = "blue", group = 'proj')

```

```{asis, echo = {{proj_area_knit & proj_area_extent_knit}} , eval = {{proj_area_knit & proj_area_extent_knit }}, include = {{proj_area_knit & proj_area_extent_knit}}}
## Project model
Projecting the model to a new user provided area 
```

```{r, echo = {{proj_area_knit & proj_area_extent_knit}}, include = {{proj_area_knit & proj_area_extent_knit}}}
# First must generate the projection area based on user provided files
  ##User must input the path to shapefile or csv file and the file name 
proj_userExt_{{spAbr}} <- proj_userExtent(
  bgShp_path = "Input path here",
  bgShp_name = "Input file name here",
  userBgBuf = {{BgBuf_rmd}})

# Create object of projection variables
projAreaEnvs_{{spAbr}} <- envs_{{spAbr}}
# Generate a projection of the model to the desired area
proj_area_{{spAbr}} <- proj_area(
  evalOut = model_{{spAbr}},
  curModel = "{{curModel_rmd}}",
  envs = projAreaEnvs_{{spAbr}} , 
  outputType = "{{outputType_rmd}}",
  alg = "{{alg_rmd}}",
  clamp = {{clamp_rmd}},
  pjExt = proj_userExt_{{spAbr}}) 
#store the cropped projection variables
projExt_{{spAbr}} <- proj_area_{{spAbr}}$projExt
 
 ###Make map of projection
bb_{{spAbr}} <-  bgExt_{{spAbr}}@bbox
bbZoom <- alfred.polyZoom(bb_{{spAbr}}[1, 1], bb_{{spAbr}}[2, 1], bb_{{spAbr}}[1, 2], 
                   bb_{{spAbr}}[2, 2], fraction = 0.05)
mapProjVals_{{spAbr}} <- alfred.getRasterVals(proj_area_{{spAbr}}$projArea,"{{outputType_rmd}}")
rasCols_{{spAbr}} <- c("#2c7bb6", "#abd9e9", "#ffffbf", "#fdae61", "#d7191c")
# if no threshold specified
legendPal <- colorNumeric(rev(rasCols_{{spAbr}}), mapProjVals_{{spAbr}}, na.color = 'transparent')
rasPal_{{spAbr}} <- colorNumeric(rasCols_{{spAbr}}, mapProjVals_{{spAbr}}, na.color = 'transparent')
m <- leaflet() %>% addProviderTiles(providers$Esri.WorldTopoMap) 
m %>%
  fitBounds(bbZoom[1], bbZoom[2], bbZoom[3], bbZoom[4]) %>%
  leaflet::addLegend("bottomright", pal = legendPal,
            title = "Predicted Suitability<br>(Projected)",
            values = mapProjVals_{{spAbr}}, layerId = 'proj',
            labFormat = alfred.reverseLabel(2, reverse_order = TRUE)) %>%
# map model prediction raster and projection polygon
  clearMarkers() %>% clearShapes() %>% removeImage('projRas') %>%
  addRasterImage(proj_area_{{spAbr}}$projArea, colors = rasPal_{{spAbr}}, opacity = 0.7,
                 layerId = 'projRas', group = 'proj', method = "ngb") %>%
 ##add projection polygon (user provided area)
  addPolygons(data = proj_userExt_{{spAbr}}, fill = FALSE,
              weight = 4, color = "blue", group = 'proj')
```

```{asis, echo = {{proj_area_knit & proj_area_extent_knit & proj_area_threshold_knit}} , eval = {{proj_area_knit & proj_area_extent_knit & proj_area_threshold_knit}}, include = {{proj_area_knit & proj_area_extent_knit & proj_area_threshold_knit}}}
## Project model
Projecting the model to a new user provided area using a "{{proj_thresholdRule_rmd}}" threshold of {{proj_threshold_rmd}}. 
```

```{r, echo = {{proj_area_knit & proj_area_extent_knit & proj_area_threshold_knit}}, include = {{proj_area_knit & proj_area_extent_knit & proj_area_threshold_knit}}}
# First must generate the projection area based on user provided files
  ##User must input the path to shapefile or csv file and the file name 
proj_userExt_{{spAbr}} <- proj_userExtent(
  bgShp_path = "Input path here",
  bgShp_name = "Input file name here",
  userBgBuf = {{BgBuf_rmd}})
# Create object of projection variables
projAreaEnvs_{{spAbr}} <- envs_{{spAbr}}
# Generate a projection of the model to the desired area
proj_area_{{spAbr}} <- proj_area(
  evalOut = model_{{spAbr}},
  curModel = "{{curModel_rmd}}",
  envs = projAreaEnvs_{{spAbr}} , 
  outputType = "{{outputType_rmd}}",
  alg = "{{alg_rmd}}",
  clamp = {{clamp_rmd}},
  pjExt = proj_userExt_{{spAbr}}) 

# store the cropped projection variables
projExt_{{spAbr}} <- proj_area_{{spAbr}}$projExt
# extract the suitability values for all occurrences
occs_xy_{{spAbr}} <- occs_{{spAbr}}[c('longitude', 'latitude')]
# determine the threshold based on the current prediction
occPredVals_{{spAbr}} <- raster::extract(predSel_{{spAbr}}, occs_xy_{{spAbr}})
# Define probability of quantile based on selected threshold
proj_thresProb_{{spAbr}} <- switch("{{proj_thresholdRule_rmd}}", 
                                   "mtp" = 0, "p10" = 0.1, "qtp" = {{proj_probQuantile_rmd}})
# Define threshold value
proj_thres_{{spAbr}} <- stats::quantile(occPredVals_{{spAbr}}, 
                                        probs = proj_thresProb_{{spAbr}})
# Add threshold if specified 
proj_area_{{spAbr}} <- proj_area_{{spAbr}}$projArea > proj_thresProb_{{spAbr}}

##Make map
###Make map of projection
bb_{{spAbr}} <-  bgExt_{{spAbr}}@bbox
bbZoom <- alfred.polyZoom(bb_{{spAbr}}[1, 1], bb_{{spAbr}}[2, 1], bb_{{spAbr}}[1, 2], 
                   bb_{{spAbr}}[2, 2], fraction = 0.05)
mapProjVals_{{spAbr}} <- alfred.getRasterVals(proj_area_{{spAbr}},"{{outputType_rmd}}")

  # if threshold specified
rasPal_{{spAbr}} <- c('gray', 'red')
m <- leaflet() %>% addProviderTiles(providers$Esri.WorldTopoMap) 
m %>%
  fitBounds(bbZoom[1], bbZoom[2], bbZoom[3], bbZoom[4]) %>%
  leaflet::addLegend("bottomright", colors = c('gray', 'red'),
            title = "Thresholded Suitability<br>(Projected)",
            labels = c("predicted absence", "predicted presence"),
            opacity = 1, layerId = 'proj')%>%
# map model prediction raster and projection polygon
  clearMarkers() %>% clearShapes() %>% removeImage('projRas') %>%
  addRasterImage(proj_area_{{spAbr}}, colors = rasPal_{{spAbr}}, opacity = 0.7,
                 layerId = 'projRas', group = 'proj', method = "ngb") %>%
 ##add projection polygon (user provided area)
  addPolygons(data = proj_userExt_{{spAbr}}, fill = FALSE,
              weight = 4, color = "blue", group = 'proj')

```
