```{asis, echo = {{proj_user_knit & !proj_user_user_knit & !proj_user_drawn_knit}}, eval = {{proj_user_knit & !proj_user_user_knit & !proj_user_drawn_knit}}, include = {{proj_user_knit & !proj_user_user_knit & !proj_user_drawn_knit}}}
### Project model
Projecting the model to the same modelling area with no threshold rule. Environmental layers for projecting are user provided.
```

```{r, echo = {{proj_user_knit & !proj_user_user_knit & !proj_user_drawn_knit}}, include = {{proj_user_knit & !proj_user_user_knit & !proj_user_drawn_knit}}}
## Specify the directory with the environmental variables
dir_envsPj_{{spAbr}} <- ""
envsPj_path <- file.path(dir_envsPj_{{spAbr}}, {{userPjName_rmd}})
# Load user environmental variables
projUserEnvs_{{spAbr}}  <- envs_userEnvs(
  rasPath = envsPj_path,
  rasName = {{userPjName_rmd}}
)
# Project model 
proj_userEnvs_{{spAbr}} <- proj_userEnvs(
  evalOut = model_{{spAbr}},
  curModel= "{{curModel_rmd}}",
  envs = projUserEnvs_{{spAbr}} ,
  pjExt = bgExt_{{spAbr}},
  alg = "{{alg_rmd}}",
  outputType = "{{outputType_rmd}}",
  clamp = {{clamp_rmd}}
 )
# store the cropped projection variables
projExt_{{spAbr}} <- proj_userEnvs_{{spAbr}}$projExt

###Make map of projection
bb_{{spAbr}} <-  bgExt_{{spAbr}}@bbox
bbZoom <- polyZoom(bb_{{spAbr}}[1, 1], bb_{{spAbr}}[2, 1], bb_{{spAbr}}[1, 2], 
                   bb_{{spAbr}}[2, 2], fraction = 0.05)
mapProjVals_{{spAbr}} <- getRasterVals(proj_userEnvs_{{spAbr}}$projUser, "{{outputType_rmd}}")
rasCols_{{spAbr}} <- c("#2c7bb6", "#abd9e9", "#ffffbf", "#fdae61", "#d7191c")
# if no threshold specified
legendPal <- colorNumeric(rev(rasCols_{{spAbr}}), mapProjVals_{{spAbr}}, na.color = 'transparent')
rasPal_{{spAbr}} <- colorNumeric(rasCols_{{spAbr}}, mapProjVals_{{spAbr}}, na.color = 'transparent')
m <- leaflet() %>% addProviderTiles(providers$Esri.WorldTopoMap) 
m %>%
  fitBounds(bbZoom[1], bbZoom[2], bbZoom[3], bbZoom[4]) %>%
  leaflet::addLegend("bottomright", pal = legendPal,
            title = "Predicted Suitability<br>(Projected)",
            values = mapProjVals_{{spAbr}}, layerId = 'proj',
            labFormat = reverseLabels(2, reverse_order = TRUE)) %>%
# map model prediction raster and projection polygon
  clearMarkers() %>% clearShapes() %>% removeImage('projRas') %>%
  addRasterImage(proj_userEnvs_{{spAbr}}$projUser, colors = rasPal_{{spAbr}}, opacity = 0.7,
                 layerId = 'projRas', group = 'proj', method = "ngb") %>%
 ##add projection polygon (same modeling area)
  addPolygons(data = bgExt_{{spAbr}}, fill = FALSE,
              weight = 4, color = "blue", group = 'proj')
```

```{asis, echo = {{proj_user_knit & proj_user_threshold_knit & !proj_user_user_knit & !proj_user_drawn_knit}}, eval = {{proj_user_knit & proj_user_threshold_knit & !proj_user_user_knit & !proj_user_drawn_knit}}, include = {{proj_user_knit & proj_user_threshold_knit & !proj_user_user_knit & !proj_user_drawn_knit}}}
### Project model
Projecting the model to the same modelling area with a "{{proj_thresholdRule_rmd}}" threshold rule of {{proj_threshold_rmd}}. Environmental layers for projecting are user provided.
```

```{r, echo = {{proj_user_knit & proj_user_threshold_knit & !proj_user_user_knit & !proj_user_drawn_knit}}, include = {{proj_user_knit & proj_user_threshold_knit & !proj_user_user_knit & !proj_user_drawn_knit}}}
## Specify the directory with the environmental variables
dir_envsPj_{{spAbr}} <- ""
envsPj_path <- file.path(dir_envsPj_{{spAbr}}, {{userPjName_rmd}})
# Load user environmental variables
projUserEnvs_{{spAbr}}  <- envs_userEnvs(
  rasPath = envsPj_path,
  rasName = {{userPjName_rmd}}
)
# Project model 
proj_userEnvs_{{spAbr}} <- proj_userEnvs(
  evalOut = model_{{spAbr}},
  curModel= "{{curModel_rmd}}",
  envs = projUserEnvs_{{spAbr}} ,
  pjExt = bgExt_{{spAbr}},
  alg = "{{alg_rmd}}",
  outputType = "{{outputType_rmd}}",
  clamp = {{clamp_rmd}}
  )
# store the cropped projection variables
projExt_{{spAbr}} <- proj_userEnvs_{{spAbr}}$projExt
# extract the suitability values for all occurrences
occs_xy_{{spAbr}} <- occs_{{spAbr}}[c('longitude', 'latitude')]
# determine the threshold based on the current prediction
occPredVals_{{spAbr}} <- raster::extract(predSel_{{spAbr}}, occs_xy_{{spAbr}})
# Define probability of quantile based on selected threshold
proj_thresProb_{{spAbr}} <- switch("{{proj_thresholdRule_rmd}}", 
                                   "mtp" = 0, "p10" = 0.1, "qtp" = {{proj_probQuantile_rmd}})
# Define threshold value
proj_thres_{{spAbr}} <- quantile(occPredVals_{{spAbr}}, 
                                 probs = proj_thresProb_{{spAbr}})
# Add threshold if specified 
proj_userEnvs_{{spAbr}} <- proj_userEnvs_{{spAbr}}$projUser > proj_thres_{{spAbr}}

##Make map
###Make map of projection
bb_{{spAbr}} <-  bgExt_{{spAbr}}@bbox
bbZoom <- polyZoom(bb_{{spAbr}}[1, 1], bb_{{spAbr}}[2, 1], bb_{{spAbr}}[1, 2], 
                   bb_{{spAbr}}[2, 2], fraction = 0.05)
mapProjVals_{{spAbr}} <- getRasterVals(proj_userEnvs_{{spAbr}},"{{outputType_rmd}}")

  # if threshold specified
rasPal_{{spAbr}} <- c('gray', 'red')
m <- leaflet() %>% addProviderTiles(providers$Esri.WorldTopoMap) 
m %>%
  fitBounds(bbZoom[1], bbZoom[2], bbZoom[3], bbZoom[4]) %>%
  leaflet::addLegend("bottomright", colors = c('gray', 'red'),
            title = "Thresholded Suitability<br>(Projected)",
            labels = c("predicted absence", "predicted presence"),
            opacity = 1, layerId = 'proj')%>%

# map model prediction raster and projection polygon
  clearMarkers() %>% clearShapes() %>% removeImage('projRas') %>%
  addRasterImage(proj_userEnvs_{{spAbr}}, colors = rasPal_{{spAbr}}, opacity = 0.7,
                 layerId = 'projRas', group = 'proj', method = "ngb") %>%
 ##add projection polygon (same modeling area)
  addPolygons(data = bgExt_{{spAbr}}, fill = FALSE,
              weight = 4, color = "blue", group = 'proj')
```

```{asis, echo = {{proj_user_knit & !proj_user_user_knit & proj_user_drawn_knit}}, eval = {{proj_user_knit & !proj_user_user_knit & proj_user_drawn_knit}}, include = {{proj_user_knit & !proj_user_user_knit & proj_user_drawn_knit }}}
### Project model
Projecting the model to a user drawn area with no threshold rule. Environmental layers for projecting are user provided.
```

```{r, echo = {{proj_user_knit & !proj_user_user_knit & proj_user_drawn_knit}}, include = {{proj_user_knit & !proj_user_user_knit & proj_user_drawn_knit}}}
## Specify the directory with the environmental variables
dir_envsPj_{{spAbr}} <- ""
envsPj_path <- file.path(dir_envsPj_{{spAbr}}, {{userPjName_rmd}})
# Load user environmental variables
projUserEnvs_{{spAbr}} <- envs_userEnvs(
  rasPath = envsPj_path,
  rasName = {{userPjName_rmd}}
)
# Generate the projection area according to the drawn polygon in the GUI
proj_draw_{{spAbr}} <- proj_draw(
  polyPjXY = matrix({{polyPjXY_rmd}}, ncol = 2, byrow = FALSE),
  polyPjID = {{polyPjID_rmd}},
  drawPjBuf = {{BgBuf_rmd}})
# Project model 
proj_userEnvs_{{spAbr}} <- proj_userEnvs(
  evalOut = model_{{spAbr}},
  curModel= "{{curModel_rmd}}",
  envs = projUserEnvs_{{spAbr}} ,
  pjExt = proj_draw_{{spAbr}},
  alg = "{{alg_rmd}}",
  outputType = "{{outputType_rmd}}",
  clamp = {{clamp_rmd}}
  )
#store the cropped projection variables
projExt_{{spAbr}} <- proj_userEnvs_{{spAbr}}$projExt

###Make map of projection
bb_{{spAbr}} <-  bgExt_{{spAbr}}@bbox
bbZoom <- polyZoom(bb_{{spAbr}}[1, 1], bb_{{spAbr}}[2, 1], bb_{{spAbr}}[1, 2], 
                   bb_{{spAbr}}[2, 2], fraction = 0.05)
mapProjVals_{{spAbr}} <- getRasterVals( proj_userEnvs_{{spAbr}}$projUser,"{{outputType_rmd}}")
rasCols_{{spAbr}} <- c("#2c7bb6", "#abd9e9", "#ffffbf", "#fdae61", "#d7191c")
# if no threshold specified
legendPal <- colorNumeric(rev(rasCols_{{spAbr}}), mapProjVals_{{spAbr}}, na.color = 'transparent')
rasPal_{{spAbr}} <- colorNumeric(rasCols_{{spAbr}}, mapProjVals_{{spAbr}}, na.color = 'transparent')
m <- leaflet() %>% addProviderTiles(providers$Esri.WorldTopoMap) 
m %>%
  fitBounds(bbZoom[1], bbZoom[2], bbZoom[3], bbZoom[4]) %>%
  leaflet::addLegend("bottomright", pal = legendPal,
            title = "Predicted Suitability<br>(Projected)",
            values = mapProjVals_{{spAbr}}, layerId = 'proj',
            labFormat = reverseLabels(2, reverse_order = TRUE)) %>%
# map model prediction raster and projection polygon
  clearMarkers() %>% clearShapes() %>% removeImage('projRas') %>%
  addRasterImage(proj_userEnvs_{{spAbr}}$projUser, colors = rasPal_{{spAbr}}, opacity = 0.7,
                 layerId = 'projRas', group = 'proj', method = "ngb") %>%
 ##add projection polygon (user drawn area)
  addPolygons(data = proj_draw_{{spAbr}}, fill = FALSE,
              weight = 4, color = "blue", group = 'proj')
```

```{asis, echo = {{proj_user_knit & !proj_user_user_knit & proj_user_drawn_knit & proj_user_threshold_knit}}, eval = {{proj_user_knit & !proj_user_user_knit & proj_user_drawn_knit & proj_user_threshold_knit}}, include = {{proj_user_knit & !proj_user_user_knit & proj_user_drawn_knit & proj_user_threshold_knit }}}
### Project model
Projecting the model to a user drawn area with a "{{proj_thresholdRule_rmd}}" threshold rule of {{proj_threshold_rmd}}. Environmental layers for projecting are user provided.
```

```{r, echo = {{proj_user_knit & !proj_user_user_knit & proj_user_drawn_knit & proj_user_threshold_knit}}, include = {{proj_user_knit & !proj_user_user_knit & proj_user_drawn_knit & proj_user_threshold_knit}}}
## Specify the directory with the environmental variables
dir_envsPj_{{spAbr}} <- ""
envsPj_path <- file.path(dir_envsPj_{{spAbr}}, {{userPjName_rmd}})
# Load user environmental variables
projUserEnvs_{{spAbr}}  <- envs_userEnvs(
  rasPath = envsPj_path,
  rasName = {{userPjName_rmd}}
)
# Generate the projection area according to the drawn polygon in the GUI
proj_draw_{{spAbr}} <-proj_draw(
  polyPjXY = matrix({{polyPjXY_rmd}}, ncol = 2, byrow = FALSE),
  polyPjID = {{polyPjID_rmd}},
  drawPjBuf = {{BgBuf_rmd}})
# Project model 
proj_userEnvs_{{spAbr}} <- proj_userEnvs(
  evalOut = model_{{spAbr}},
  curModel= "{{curModel_rmd}}",
  envs = projUserEnvs_{{spAbr}} ,
  pjExt = proj_draw_{{spAbr}},
  alg = "{{alg_rmd}}",
  outputType = "{{outputType_rmd}}",
  clamp = {{clamp_rmd}}
 )

# store the cropped projection variables
projExt_{{spAbr}} <- proj_userEnvs_{{spAbr}}$projExt
# extract the suitability values for all occurrences
occs_xy_{{spAbr}} <- occs_{{spAbr}}[c('longitude', 'latitude')]
# determine the threshold based on the current prediction
occPredVals_{{spAbr}} <- raster::extract(predSel_{{spAbr}}, occs_xy_{{spAbr}})
# Define probability of quantile based on selected threshold
proj_thresProb_{{spAbr}} <- switch("{{proj_thresholdRule_rmd}}", 
                                   "mtp" = 0, "p10" = 0.1, "qtp" = {{proj_probQuantile_rmd}})
# Define threshold value
proj_thres_{{spAbr}} <- quantile(occPredVals_{{spAbr}}, 
                                 probs = proj_thresProb_{{spAbr}})
# Add threshold if specified 
proj_userEnvs_{{spAbr}} <- proj_userEnvs_{{spAbr}}$projUser > proj_thres_{{spAbr}}

##Make map
###Make map of projection
bb_{{spAbr}} <-  bgExt_{{spAbr}}@bbox
bbZoom <- polyZoom(bb_{{spAbr}}[1, 1], bb_{{spAbr}}[2, 1], bb_{{spAbr}}[1, 2], 
                   bb_{{spAbr}}[2, 2], fraction = 0.05)
mapProjVals_{{spAbr}} <- getRasterVals(proj_userEnvs_{{spAbr}},"{{outputType_rmd}}")

# if threshold specified
rasPal_{{spAbr}} <- c('gray', 'red')
m <- leaflet() %>% addProviderTiles(providers$Esri.WorldTopoMap) 
m %>%
  fitBounds(bbZoom[1], bbZoom[2], bbZoom[3], bbZoom[4]) %>%
  leaflet::addLegend("bottomright", colors = c('gray', 'red'),
            title = "Thresholded Suitability<br>(Projected)",
            labels = c("predicted absence", "predicted presence"),
            opacity = 1, layerId = 'proj')%>%
# map model prediction raster and projection polygon
  clearMarkers() %>% clearShapes() %>% removeImage('projRas') %>%
  addRasterImage(proj_userEnvs_{{spAbr}}, colors = rasPal_{{spAbr}}, opacity = 0.7,
                 layerId = 'projRas', group = 'proj', method = "ngb") %>%
 ##add projection polygon (user drawn area)
  addPolygons(data = proj_draw_{{spAbr}}, fill = FALSE,
              weight = 4, color = "blue", group = 'proj')
```

```{asis, echo = {{proj_user_knit & proj_user_user_knit & !proj_user_drawn_knit}}, eval = {{proj_user_knit & proj_user_user_knit & !proj_user_drawn_knit}}, include = {{proj_user_knit & proj_user_user_knit & !proj_user_drawn_knit }}}
### Project model
Projecting the model to a user provided area with no threshold rule. Environmental layers for projecting are user provided.
```

```{r, echo = {{proj_user_knit & proj_user_user_knit & !proj_user_drawn_knit}}, include = {{proj_user_knit & proj_user_user_knit & !proj_user_drawn_knit}}}
## Specify the directory with the environmental variables
dir_envsPj_{{spAbr}} <- ""
envsPj_path <- file.path(dir_envsPj_{{spAbr}}, {{userPjName_rmd}})
# Load user environmental variables
projUserEnvs_{{spAbr}}  <- envs_userEnvs(
  rasPath = envsPj_path,
  rasName = {{userPjName_rmd}}
)

# Generate the projection area based on user provided files
##User must input the path to shapefile or csv file and the file name 
proj_userExt_{{spAbr}} <- proj_userExtent(
  bgShp_path = "Input path here",
  bgShp_name = "Input file name here",
  userBgBuf = {{BgBuf_rmd}})
# Project model 
proj_userEnvs_{{spAbr}} <- proj_userEnvs(
  evalOut = model_{{spAbr}},
  curModel= "{{curModel_rmd}}",
  envs = projUserEnvs_{{spAbr}} ,
  pjExt = proj_userExt_{{spAbr}},
  alg = "{{alg_rmd}}",
  outputType = "{{outputType_rmd}}",
  clamp = {{clamp_rmd}}
 )
# store the cropped projection variables
projExt_{{spAbr}} <- proj_userEnvs_{{spAbr}}$projExt

###Make map of projection
bb_{{spAbr}} <-  bgExt_{{spAbr}}@bbox
bbZoom <- polyZoom(bb_{{spAbr}}[1, 1], bb_{{spAbr}}[2, 1], bb_{{spAbr}}[1, 2], 
                   bb_{{spAbr}}[2, 2], fraction = 0.05)
mapProjVals_{{spAbr}} <- getRasterVals(proj_userEnvs_{{spAbr}}$projUser,"{{outputType_rmd}}")
rasCols_{{spAbr}} <- c("#2c7bb6", "#abd9e9", "#ffffbf", "#fdae61", "#d7191c")
# if no threshold specified
legendPal <- colorNumeric(rev(rasCols_{{spAbr}}), mapProjVals_{{spAbr}}, na.color = 'transparent')
rasPal_{{spAbr}} <- colorNumeric(rasCols_{{spAbr}}, mapProjVals_{{spAbr}}, na.color = 'transparent')
m <- leaflet() %>% addProviderTiles(providers$Esri.WorldTopoMap) 
m %>%
  fitBounds(bbZoom[1], bbZoom[2], bbZoom[3], bbZoom[4]) %>%
  leaflet::addLegend("bottomright", pal = legendPal,
            title = "Predicted Suitability<br>(Projected)",
            values = mapProjVals_{{spAbr}}, layerId = 'proj',
            labFormat = reverseLabels(2, reverse_order = TRUE)) %>%

# map model prediction raster and projection polygon
  clearMarkers() %>% clearShapes() %>% removeImage('projRas') %>%
  addRasterImage(proj_userEnvs_{{spAbr}}$projUser, colors = rasPal_{{spAbr}}, opacity = 0.7,
                 layerId = 'projRas', group = 'proj', method = "ngb") %>%
 ##add projection polygon (user provided area)
  addPolygons(data = proj_userExt_{{spAbr}}, fill = FALSE,
              weight = 4, color = "blue", group = 'proj')
```

```{asis, echo = {{proj_user_knit & proj_user_user_knit & !proj_user_drawn_knit & proj_user_threshold_knit}}, eval = {{proj_user_knit & proj_user_user_knit & !proj_user_drawn_knit & proj_user_threshold_knit}}, include = {{proj_user_knit & proj_user_user_knit & !proj_user_drawn_knit & proj_user_threshold_knit }}}
### Project model
Projecting the model to a user provided area with a "{{proj_thresholdRule_rmd}}" threshold rule of {{proj_threshold_rmd}}. Environmental layers for projecting are user provided.
```

```{r, echo = {{proj_user_knit & proj_user_user_knit & !proj_user_drawn_knit & proj_user_threshold_knit}}, include = {{proj_user_knit & proj_user_user_knit & !proj_user_drawn_knit & proj_user_threshold_knit}}}
## Specify the directory with the environmental variables
dir_envsPj_{{spAbr}} <- ""
envsPj_path <- file.path(dir_envsPj_{{spAbr}}, {{userPjName_rmd}})
# Load user environmental variables
projUserEnvs_{{spAbr}}  <- envs_userEnvs(
  rasPath = envsPj_path,
  rasName = {{userPjName_rmd}}
)
# Generate the projection area based on user provided files
  ##User must input the path to shapefile or csv file and the file name 
proj_userExt_{{spAbr}} <- proj_userExtent(
  bgShp_path = "Input path here",
  bgShp_name = "Input file name here",
  userBgBuf = {{BgBuf_rmd}})
# Project model 
proj_userEnvs_{{spAbr}} <- proj_userEnvs(
  evalOut = model_{{spAbr}},
  curModel= "{{curModel_rmd}}",
  envs = projUserEnvs_{{spAbr}} ,
  pjExt = proj_userExt_{{spAbr}},
  alg = "{{alg_rmd}}",
  outputType = "{{outputType_rmd}}",
  clamp = {{clamp_rmd}}
 )

# store the cropped projection variables
projExt_{{spAbr}} <- proj_userEnvs_{{spAbr}}$projExt
# extract the suitability values for all occurrences
occs_xy_{{spAbr}} <- occs_{{spAbr}}[c('longitude', 'latitude')]
# determine the threshold based on the current prediction
occPredVals_{{spAbr}} <- raster::extract(predSel_{{spAbr}}, occs_xy_{{spAbr}})
# Define probability of quantile based on selected threshold
proj_thresProb_{{spAbr}} <- switch("{{proj_thresholdRule_rmd}}", 
                                   "mtp" = 0, "p10" = 0.1, "qtp" = {{proj_probQuantile_rmd}})
# Define threshold value
proj_thres_{{spAbr}} <- quantile(occPredVals_{{spAbr}}, 
                                 probs = proj_thresProb_{{spAbr}})
# Add threshold if specified 
proj_userEnvs_{{spAbr}} <- proj_userEnvs_{{spAbr}}$projUser > proj_thres_{{spAbr}}

##Make map
###Make map of projection
bb_{{spAbr}} <-  bgExt_{{spAbr}}@bbox
bbZoom <- polyZoom(bb_{{spAbr}}[1, 1], bb_{{spAbr}}[2, 1], bb_{{spAbr}}[1, 2], 
                   bb_{{spAbr}}[2, 2], fraction = 0.05)
mapProjVals_{{spAbr}} <- getRasterVals(proj_userEnvs_{{spAbr}},"{{outputType_rmd}}")

  # if threshold specified
rasPal_{{spAbr}} <- c('gray', 'red')
m <- leaflet() %>% addProviderTiles(providers$Esri.WorldTopoMap) 
m %>%
  fitBounds(bbZoom[1], bbZoom[2], bbZoom[3], bbZoom[4]) %>%
  leaflet::addLegend("bottomright", colors = c('gray', 'red'),
            title = "Thresholded Suitability<br>(Projected)",
            labels = c("predicted absence", "predicted presence"),
            opacity = 1, layerId = 'proj')%>%

# map model prediction raster and projection polygon
  clearMarkers() %>% clearShapes() %>% removeImage('projRas') %>%
  addRasterImage(proj_userEnvs_{{spAbr}}, colors = rasPal_{{spAbr}}, opacity = 0.7,
                 layerId = 'projRas', group = 'proj', method = "ngb") %>%
 ##add projection polygon (user provided area)
  addPolygons(data = proj_userExt_{{spAbr}}, fill = FALSE,
              weight = 4, color = "blue", group = 'proj')
```

